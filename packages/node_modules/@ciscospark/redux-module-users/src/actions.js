export const STORE_CURRENT_USER = `user/STORE_CURRENT_USER`;
export const STORE_USER = `user/STORE_USER`;


function storeCurrentUser(user) {
  return {
    type: STORE_CURRENT_USER,
    payload: {
      user
    }
  };
}

function storeUser(user) {
  return {
    type: STORE_USER,
    payload: {
      user
    }
  };
}


/**
 * Get current user who has authenticated with access token
 *
 * @export
 * @param {Object} sparkInstance
 * @returns
 */

export function getCurrentUser(sparkInstance) {
  return (dispatch) => sparkInstance.internal.user.get()
    .then((user) => dispatch(storeCurrentUser(user)))
    .catch((error) => Promise.reject(error));
}

/**
 * Retrieves user obect from the server
 *
 * @export
 * @param {Object} person
 * @param {String} person.toPersonEmail
 * @param {String} person.toPersonId
 * @param {Object} sparkInstance
 * @returns {Promise}
 */
export function getUser({toPersonEmail, toPersonId}, sparkInstance) {
  return (dispatch, getStore) => {
    const store = getStore();
    const handleResponse = (person) => dispatch(storeUser(person));
    const handleError = (error) => Promise.reject(error);

    if (!store.has([`items`, toPersonEmail, `isPending`])
      && !store.has([`items`, toPersonId, `isPending`])) {
      if (toPersonEmail) {
        return sparkInstance.people.list({email: toPersonEmail})
          .then((res) => res.items[0])
          .then(handleResponse)
          .catch(handleError);
      }
      else if (toPersonId) {
        return sparkInstance.people.get(toPersonId)
          .then(handleResponse)
          .catch(handleError);
      }

    }
    return Promise.reject(new Error(`toPersonEmail or toPersonId is required`));
  };
}
