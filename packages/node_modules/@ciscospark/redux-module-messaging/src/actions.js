import {
  isImage,
  sanitize
} from '@ciscospark/react-component-utils';

import {
  constructMessage,
  constructMessageWithContent,
  revokeObjectURL,
  createObjectURL,
  createMessageObject,
  cleanupAfterSubmit
} from './helpers';

export const ADD_FILES_TO_MESSAGE = 'messaging/ADD_FILES_TO_MESSAGE';
export const ADD_INFLIGHT_MESSAGE = 'messaging/ADD_INFLIGHT_MESSAGE';
export const REMOVE_FAILED_MESSAGE = 'messaging/REMOVE_FAILED_MESSAGE';
export const REMOVE_FILE_FROM_MESSAGE = 'messaging/REMOVE_FILE_FROM_MESSAGE';
export const REMOVE_INFLIGHT_MESSAGE = 'messaging/REMOVE_INFLIGHT_MESSAGE';
export const RESET_MESSAGE = 'messaging/RESET_MESSAGE';
export const SAVE_SHARE = 'messaging/SAVE_SHARE';
export const SUBMIT_MESSAGE_START = 'messaging/SUBMIT_MESSAGE_START';
export const SUBMIT_MESSAGE_FAILURE = 'messaging/SUBMIT_MESSAGE_FAILURE';
export const UPDATE_MESSAGE_STATUS = 'messaging/UPDATE_MESSAGE_STATUS';
export const STORE_MESSAGE_TEXT = 'messaging/STORE_MESSAGE_TEXT';

export function addFilesToMessage(files) {
  return {
    type: ADD_FILES_TO_MESSAGE,
    payload: {
      files
    }
  };
}

function addInflightMessage(message) {
  return {
    type: ADD_INFLIGHT_MESSAGE,
    payload: {
      message
    }
  };
}


function removeFailedMessage(id) {
  return {
    type: REMOVE_FAILED_MESSAGE,
    payload: {
      id
    }
  };
}

export function removeFileFromMessage(id) {
  return {
    type: REMOVE_FILE_FROM_MESSAGE,
    payload: {
      id
    }
  };
}

export function removeInflightMessage(id) {
  return {
    type: REMOVE_INFLIGHT_MESSAGE,
    payload: {
      id
    }
  };
}

export function resetMessage() {
  return {
    type: RESET_MESSAGE
  };
}

export function saveShareMessage(share) {
  return {
    type: SAVE_SHARE,
    payload: {
      share
    }
  };
}

export function submitMessageStart() {
  return {
    type: SUBMIT_MESSAGE_START
  };
}

export function submitMessageFailure(message, error) {
  return {
    type: SUBMIT_MESSAGE_FAILURE,
    payload: {
      message,
      error
    }
  };
}

export function updateMessageStatus(status) {
  return {
    type: UPDATE_MESSAGE_STATUS,
    payload: {
      status
    }
  };
}

export function storeMessageText(text, cleanText) {
  return {
    type: STORE_MESSAGE_TEXT,
    payload: {
      text,
      cleanText
    }
  };
}

/**
 * Adds file to message, creates Share if not present, starts upload
 *
 * @param {object} sparkInstance - spark instance
 * @param {object} options
 * @param {object} options.conversation object from SDK stored in space store
 * @param {Map} options.message - from store
 * @param {Array} options.files
 * @returns {function}
 */
export function addFiles(sparkInstance, {conversation, message, files}) {
  return (dispatch) => {
    if (files && files.length) {
      let {share} = message;
      if (!share) {
        share = sparkInstance.internal.conversation.makeShare(conversation);
        // Store share object to be used later
        dispatch(saveShareMessage(share));
      }

      let cleanFiles;
      if (files && files.length) {
        cleanFiles = files.map((file) => {
          const clean = sanitize(file);
          // Create thumbnail objectURL
          if (isImage(clean)) {
            clean.thumbnail = createObjectURL(clean);
          }
          return clean;
        });
      }
      dispatch(updateMessageStatus({isUploadingShare: true}));
      dispatch(addFilesToMessage(cleanFiles));
      cleanFiles.forEach((file) => share.add(file));
    }
    return Promise.resolve();
  };
}

/**
* Removes file from Share and from store
*
* @param {string} id - clientTempId key of stored file
* @param {Map} message - from store
* @returns {function}
*/
export function removeFile(id, message) {
  return (dispatch) => {
    const file = message.getIn(['files', id]);
    return message.share.remove(file).then(() => {
      revokeObjectURL(file);
      return dispatch(removeFileFromMessage(id));
    });
  };
}

/**
* Constructs and sends message to a space
*
* @param {object} sparkInstance - spark instance from store
* @param {object} options
* @param {object} options.conversation - object from SDK stored in space store
* @param {Map} options.message - from store (immutable object)
* @param {object} options.user - from store
* @returns {function}
*/
export function submitMessage(sparkInstance, {conversation, message, user}) {
  return (dispatch) => {
    if (message.text.length === 0 && message.files.size === 0) {
      return Promise.resolve();
    }
    const messageObject = createMessageObject(message.text);
    const {share} = message;
    if (share && message.files.size) {
      const inFlightMessage = constructMessageWithContent({
        files: message.files,
        conversation,
        messageObject,
        user,
        share
      });
      dispatch(addInflightMessage(inFlightMessage));
      // map our temp id to the in flight temp id so we can remove it when it is received
      share.object = {
        displayName: messageObject.displayName,
        content: messageObject.content,
        mentions: messageObject.mentions
      };
      share.clientTempId = inFlightMessage.clientTempId;

      return sparkInstance.internal.conversation.share(conversation, share)
        .then(() => {
          cleanupAfterSubmit(dispatch, message);
          dispatch(resetMessage());
          return message;
        })
        .catch((error) => {
          cleanupAfterSubmit(dispatch, message);
          dispatch(resetMessage());
          return dispatch(submitMessageFailure(inFlightMessage, error));
        });
    }

    if (messageObject) {
      const inFlightMessage = constructMessage({conversation, messageObject, user});
      dispatch(addInflightMessage(inFlightMessage));
      dispatch(resetMessage());
      return sparkInstance.internal.conversation
        .post(conversation, messageObject, {clientTempId: inFlightMessage.clientTempId})
        .catch((error) => dispatch(submitMessageFailure(inFlightMessage, error)));
    }
    return Promise.resolve();
  };
}

/**
 * Re-submits the failed message to the space
 * @param {object} sparkInstance
 * @param {object} failedMessage
 * @returns {function}
 */
export function retryFailedMessage(sparkInstance, failedMessage) {
  return (dispatch) => {
    // eslint-disable-reason property provided by SDK
    // eslint-disable-next-line no-underscore-dangle
    const {conversation, shareActivity, text} = failedMessage._meta;
    dispatch(removeFailedMessage(failedMessage.id));
    dispatch(addInflightMessage(failedMessage));
    if (failedMessage.verb === 'share') {
      return sparkInstance.internal.conversation.share(conversation, shareActivity)
        .catch((error) => dispatch(submitMessageFailure(failedMessage, error)));
    }
    return sparkInstance.internal.conversation
      .post(conversation, text, {clientTempId: failedMessage.clientTempId})
      .catch((error) => dispatch(submitMessageFailure(failedMessage, error)));
  };
}
