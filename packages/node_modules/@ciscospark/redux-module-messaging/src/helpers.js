import marked from 'marked';
import uuid from 'uuid';

import {escapeSync, filterSync} from '@ciscospark/helper-html';
import {isImage} from '@ciscospark/react-component-utils';

/**
 * Create objectURL
 *
 * @param {object} file
 * @returns {string}
 */
export function createObjectURL(file) {
  const urlCreator = window.URL || window.webkitURL;
  return urlCreator.createObjectURL(file);
}

/**
 * Revoke objectURL
 *
 * @param {object} file
 * @returns {undefined}
 */
export function revokeObjectURL(file) {
  const urlCreator = window.URL || window.webkitURL;
  urlCreator.revokeObjectURL(file);
}


/**
 * Parses react-mention data from input text
 *
 * @param {string} text
 * @param {string} plainText
 * @returns {Object}
 * @returns {Object.mentions}
 * @returns {Object.mentionsText}
 */

export function getMentions(text, plainText) {
  const regex = /@\{(.+?)\}\|([a-zA-Z0-9-]+)\|/g;
  const mentions = [];
  const mentionsText = text.replace(regex, (match, display, id) => {
    mentions.push({
      id,
      objectType: 'person'
    });
    return `<spark-mention data-object-type="person" data-object-id="${id}">${display}</spark-mention>`;
  });
  const mentionsPlainText = plainText.replace(regex, (match, display) => display);
  return {
    mentions,
    mentionsPlainText,
    mentionsText
  };
}

function filterMarked(content) {
  return filterSync(() => {}, {
    'spark-mention': ['data-object-type', 'data-object-id', 'data-object-url'],
    a: ['href'],
    b: [],
    blockquote: ['class'],
    strong: [],
    i: [],
    em: [],
    pre: [],
    code: ['class'],
    br: [],
    hr: [],
    p: [],
    ul: [],
    ol: [],
    li: [],
    h1: [],
    h2: [],
    h3: [],
    h4: [],
    h5: [],
    h6: []
  }, [], content)
    .replace(/\n/g, '');
}

/**
 * Creates markdown and stripped text object
 *
 * @param {string} text
 * @returns {object}
 * @returns {object.content} Converted markdown content
 * @returns {object.displayName} Raw text content
 */
export function createMessageObject(text) {
  const messageObject = {
    displayName: '',
    objectType: 'comment'
  };
  if (typeof text === 'string') {
    const origContent = text.trim();
    let content = origContent;
    let plainText = origContent;
    let hasContent = false;

    const htmlRegex = /(<([^>]+)>)/ig;
    const markedString = marked(content, {sanitize: false}) || '';
    // Remove possibly added <p></p> tags and newline
    const cleanedString = markedString.replace(/(?:^<p>)|(?:<\/p>$)|(?:<\/p>\n$)/g, '').trim();

    if (cleanedString !== origContent) {
      hasContent = true;
      content = filterMarked(cleanedString);
      // Strip html for plain text
      plainText = cleanedString.replace(/(<([^>]+)>)/ig, '');
      // Convert escaped markdown html back to html for plaintext to remove markdown chars
      plainText = plainText.replace(/(&lt;|&gt;|&amp;|&#39;|&quot;)/g, (char) => {
        switch (char) {
          case '&lt;':
            return '<';
          case '&gt;':
            return '>';
          case '&amp;':
            return '&';
          case '&#39;':
            return "'";
          case '&quot;':
            return '"';
          default:
            return char;
        }
      });
      // After converting back, if nothing changed, we have pure plain text
      // Unless the markdown html has tags (like when sending a raw link)
      if (plainText === origContent && !content.match(htmlRegex)) {
        hasContent = false;
      }
    }
    if (!hasContent && content.match(htmlRegex)) {
      // If it has raw html but no markdown, we need to escape
      content = escapeSync(cleanedString);
      hasContent = true;
    }

    const {mentions, mentionsPlainText, mentionsText} = getMentions(content, plainText);
    if (mentions && mentions.length) {
      hasContent = true;
      messageObject.mentions = {
        items: mentions
      };
      content = mentionsText;
      plainText = mentionsPlainText;
    }


    // If we had to modify the original content, send converted
    if (hasContent) {
      messageObject.content = content;
    }
    messageObject.displayName = plainText;
  }
  return messageObject;
}

/**
* Helper to reset Message
*
* @param {Map} message
*/
export function cleanupAfterSubmit(message) {
  const {files} = message;
  if (files.size) {
    files.forEach((file) => {
      revokeObjectURL(file);
    });
  }
}


/**
 * Constructs a default activity
 *
 * @export
 * @param {object} options
 * @param {object} options.conversation
 * @param {object} options.messageObject
 * @param {any} options.actor
 * @returns {object}
 */
export function constructActivity({conversation, messageObject, actor}) {
  const clientTempId = `sdk-widget-${uuid.v4()}`;
  return {
    actor: {
      displayName: actor.name,
      id: actor.id,
      objectType: 'person'
    },
    // Needed for round trip
    clientTempId,
    id: clientTempId,
    // Minimum properties needed by API
    object: messageObject,
    target: {
      id: conversation.id,
      objectType: 'conversation'
    },
    verb: 'post',
    published: new Date().toISOString(),
    clientPublished: new Date().toISOString(),
    _status: 'pending',
    _meta: {
      actor,
      conversation,
      text: messageObject
    }
  };
}


/**
 * Constructs a share activity
 *
 * @export
 * @param {object} options.conversation
 * @param {object} options.messageObject
 * @param {object} options.actor
 * @param {array} options.files
 * @param {object} options.share
 * @returns {object}
 */
export function constructMessageWithContent({
  conversation, messageObject, actor, files, share
}) {
  const activity = constructActivity({conversation, messageObject, actor});

  activity.object.objectType = 'content';
  activity.verb = 'share';
  const items = files.map((file) => {
    const item = Object.assign({}, file, {
      objectType: 'file',
      url: file.clientTempId
    });
    if (isImage(file)) {
      item.image = {
        url: file.thumbnail
      };
    }
    return item;
  });
  activity.object.files = {
    items
  };
  // eslint-disable-reason _meta comes from SDK
  // eslint-disable-next-line no-underscore-dangle
  activity._meta.shareActivity = share;

  return activity;
}
