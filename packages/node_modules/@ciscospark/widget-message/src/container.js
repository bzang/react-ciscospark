import React, {Component} from 'react';
import PropTypes from 'prop-types';
import {connect} from 'react-redux';
import {bindActionCreators} from 'redux';
import classNames from 'classnames';
import {debounce} from 'lodash';
import {autobind} from 'core-decorators';
import {intlShape} from 'react-intl';

import Notifications from '@ciscospark/react-container-notifications';
import {acknowledgeActivityOnServer} from '@ciscospark/redux-module-spaces';

import Cover from '@ciscospark/react-component-cover';
import LoadingScreen from '@ciscospark/react-component-loading-screen';
import ScrollToBottomButton from '@ciscospark/react-component-scroll-to-bottom-button';
import ActivityList from '@ciscospark/react-container-activity-list';
import MessageComposer from '@ciscospark/react-container-message-composer';
import ReadReceipts from '@ciscospark/react-container-read-receipts';
import ScrollingActivity from '@ciscospark/react-container-scrolling-activity';

import DeleteConfirmationModal from './components/DeleteConfirmationModal';
import FileDrop from './components/FileDrop';

import styles from './styles.css';
import messages from './messages';
import getMessageWidgetProps from './selector';


const propTypes = {
  // API Props
  /* eslint-disable react/no-unused-prop-types */
  hasAcknowledgementsDisabled: PropTypes.bool,
  muteNotifications: PropTypes.bool,
  onEvent: PropTypes.func,
  spaceId: PropTypes.string,
  toPersonEmail: PropTypes.string,
  toPersonId: PropTypes.string,
  eventNames: PropTypes.object,
  /* eslint-enable react/no-unused-prop-types */
  // Action Creators
  acknowledgeActivityOnServer: PropTypes.func.isRequired,
  // From selector
  space: PropTypes.object.isRequired,
  sparkInstance: PropTypes.object.isRequired,
  widgetMessage: PropTypes.object.isRequired,
  lastActivity: PropTypes.object.isRequired,
  intl: intlShape.isRequired,
  showMentions: PropTypes.bool,
  currentUser: PropTypes.object,
  toUser: PropTypes.object,
  // From withScrollHandler
  handleScrollToBottom: PropTypes.func.isRequired,
  handleScroll: PropTypes.func.isRequired,
  // From withEventHandler
  handleEvent: PropTypes.func.isRequired,
  // From withActivities
  handleActivityDelete: PropTypes.func.isRequired
};

const defaultProps = {
  hasAcknowledgementsDisabled: false,
  muteNotifications: false,
  onEvent: () => {},
  spaceId: null,
  toPersonEmail: null,
  toPersonId: null,
  eventNames: {},
  showMentions: false,
  currentUser: null,
  toUser: null
};

/**
 * MessageWidget Container
 * @extends Component
 */
export class MessageWidget extends Component {
  constructor(props) {
    super(props);
    this.handleMouseMove = debounce(this.handleMouseMove, 500, {
      leading: true,
      trailing: false
    });
  }

  shouldComponentUpdate(nextProps) {
    return nextProps !== this.props;
  }

  /**
   * Store activity list from child component
   *
   * @param {Object} ref
   * @returns {undefined}
   */
  @autobind
  getActivityList(ref) {
    this.activityList = ref;
  }


  @autobind
  acknowledgeLastActivity() {
    const {
      space,
      hasAcknowledgementsDisabled,
      lastActivity,
      sparkInstance
    } = this.props;
    if (
      space.lastAcknowledgedActivityId !== lastActivity.id &&
      !hasAcknowledgementsDisabled
    ) {
      this.props.acknowledgeActivityOnServer(sparkInstance, {conversation: space.conversation, lastActivity});
    }
  }

  /**
   * Additional actions after submitting a message
   *
   * @returns {undefined}
   */
  @autobind
  handleMessageSubmit() {
    this.activityList.scrollToBottom();
  }

  @autobind
  handleMouseMove() {
    if (this.activityList.isScrolledToBottom()) {
      this.acknowledgeLastActivity();
    }
  }

  /**
   * Renders the space area of the widget
   *
   * @returns {object}
   */
  render() {
    const {
      space,
      showMentions,
      sparkInstance,
      spaceId,
      currentUser,
      toUser,
      intl,
      widgetMessage,
      muteNotifications,
      handleActivityDelete
    } = this.props;
    const {formatMessage} = intl;

    const scrollToBottomLabel = widgetMessage.hasNewMessage ? formatMessage(messages.newMessagesMessage) : '';

    if (space && space.id) {
      const {isLoadingHistoryUp} = space;
      const displayName = space.displayName || toUser && toUser.displayName;

      return (
        <FileDrop>
          <div className={classNames('ciscospark-widget-message-main-area', styles.mainArea)} onMouseMove={this.handleMouseMove}>
            <div className={classNames('ciscospark-activity-list-wrapper', styles.activityListWrapper)}>
              <ScrollingActivity
                isLoadingHistoryUp={isLoadingHistoryUp}
                onScroll={this.props.handleScroll}
                ref={this.getActivityList}
              >
                {
                  currentUser &&
                  <ActivityList
                    newMessagesMessage={messages.newMessagesMessage}
                    onActivityDelete={handleActivityDelete}
                    spaceId={spaceId}
                  />
                }
                <div className={classNames('ciscospark-indicators', styles.indicators)}><ReadReceipts /></div>
              </ScrollingActivity>
              {
                widgetMessage.get('showScrollToBottomButton') &&
                <ScrollToBottomButton
                  label={scrollToBottomLabel}
                  onClick={this.props.handleScrollToBottom}
                />
              }
            </div>
            <div className={classNames('ciscospark-message-composer-wrapper', styles.messageComposerWrapper)}>
              <MessageComposer
                spaceId={spaceId}
                onSubmit={this.handleMessageSubmit}
                placeholder={formatMessage(messages.messageComposerPlaceholder, {displayName})}
                showMentions={showMentions}
                sparkInstance={sparkInstance}
              />
            </div>
          </div>
          <DeleteConfirmationModal />
          {
            !muteNotifications &&
            <Notifications onEvent={this.props.handleEvent} />
          }
          <Cover message={formatMessage(messages.dropzoneCoverMessage)} />
        </FileDrop>
      );
    }
    return <LoadingScreen />;
  }
}


MessageWidget.propTypes = propTypes;
MessageWidget.defaultProps = defaultProps;

export default connect(
  getMessageWidgetProps,
  (dispatch) => bindActionCreators({
    acknowledgeActivityOnServer
  }, dispatch)
)(MessageWidget);
