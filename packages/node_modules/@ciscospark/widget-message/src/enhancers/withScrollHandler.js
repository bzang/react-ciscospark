import {throttle} from 'lodash';
import {compose, lifecycle, withHandlers} from 'recompose';
import {connect} from 'react-redux';
import {bindActionCreators} from 'redux';

import {loadPreviousMessages} from '@ciscospark/redux-module-spaces';

import {
  setScrollPosition,
  updateHasNewMessage
} from './actions';

/**
 * Sets if the widget has been scrolled up from the bottom
 *
 * @param {Object} props
 * @param {boolean} isScrolledUp
 */
function setScrolledUp(props) {
  const {
    widgetMessage,
    activityList
  } = props;
  const isScrolledUp = !activityList.isScrolledToBottom();
  // Since we are triggering this every scroll, let's not attack
  // our store if we don't need to
  if (!isScrolledUp) {
    /* eslint-disable operator-linebreak */
    if (
      widgetMessage.hasNewMessage ||
      widgetMessage.hasScrolledUp ||
      widgetMessage.hasScrollToBottomButton
    ) {
      props.updateWidgetStatus({
        hasNewMessage: false,
        hasScrolledUp: false,
        hasScrollToBottomButton: false
      });
    }
  }
  /* eslint-disable operator-linebreak */
  else if (
    !widgetMessage.hasScrolledUp ||
    !widgetMessage.showScrollToBottomButton
  ) {
    props.updateWidgetStatus({
      hasScrolledUp: true,
      hasScrollToBottomButton: true
    });
  }
}


function shouldScrollToBottom(props, prevProps) {
  const {
    activityCount
  } = props;
  const prevActivitiesCount = prevProps.activityCount;
  if (activityCount && prevActivitiesCount === 0) {
    // Always scroll to the bottom when activities first load
    return true;
  }

  // Otherwise, don't scroll if we have scrolled up
  let should = true;
  if (props.widgetMessage.hasScrolledUp) {
    should = false;
  }
  return should;
}

function handleScrollToBottom() {
  return () => {
    this.activityList.scrollToBottom();
  };
}


/**
 * Perform actions when activity list scrolls
 *
 * @param {Object} props
 * @returns {function}
 */
function handleScroll(props) {
  return () => {
    const {
      activityList
    } = this;
    const {
      conversationId,
      firstActivity,
      sparkInstance
    } = props;

    if (activityList.isScrolledToBottom()) {
      setScrolledUp(props);
      if (document.hasFocus()) {
        this.acknowledgeLastActivity();
      }
    }
    else {
      setScrolledUp(true);
    }

    if (activityList.isScrolledToTop() && firstActivity.verb !== 'create') {
      // Store scroll position before loading messages so the window
      // doesn't jump after they load
      props.setScrollPosition({scrollTop: activityList.getScrollTop()});
      props.loadPreviousMessages(
        conversationId,
        firstActivity.published,
        sparkInstance
      );
    }
  };
}


export default compose(
  connect(
    null,
    (dispatch) => bindActionCreators({
      setScrolledUp,
      setScrollPosition,
      updateHasNewMessage,
      loadPreviousMessages
    }, dispatch)
  ),
  withHandlers({
    handleScrollToBottom,
    handleScroll
  }),
  lifecycle({
    constructor() {
      this.handleScroll = throttle(handleScroll, 250);
    },
    componentWillUpdate(nextProps) {
      const {props} = this;

      if (this.activityList
        && nextProps.activityCount !== props.activityCount) {
        this.scrollHeight = this.activityList.getScrollHeight();
      }
    },
    componentDidUpdate(prevProps) {
      const {
        props,
        activityList
      } = this;

      if (activityList) {
        const {
          firstActivity
        } = props;

        const previousFirstActivity = prevProps.firstActivity;
        if (firstActivity && previousFirstActivity && firstActivity.id !== previousFirstActivity.id) {
          activityList.setScrollTop(
            activityList.getScrollHeight() - this.scrollHeight
            + prevProps.widgetMessage.get('scrollPosition').scrollTop
          );
        }

        if (shouldScrollToBottom(props, prevProps)) {
          activityList.scrollToBottom();
        }
      }
    }
  })
);
