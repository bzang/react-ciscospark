import {compose, withHandlers, lifecycle} from 'recompose';

import {
  constructRoomsEventData,
  constructMessagesEventData,
  eventNames as defaultEventNames
} from '../events';

function handleEvent(props) {
  return (name, data) => {
    const {onEvent} = props;
    if (typeof onEvent === 'function') {
      onEvent(name, data);
    }
  };
}

export default compose(
  withHandlers({handleEvent}),
  lifecycle({
    componentDidMount() {
      this.eventNames = Object.assign({}, defaultEventNames, this.props.eventNames);
    },
    componentWillReceiveProps(nextProps) {
      const {eventNames} = this;
      const {
        widgetMessage,
        currentUser,
        sparkInstance,
        space
      } = nextProps;

      if (currentUser && !widgetMessage.get('isListeningToActivity')) {
        nextProps.updateWidgetState({isListeningToActivity: true});

        sparkInstance.internal.mercury.on('event:conversation.activity', (event) => {
          const {activity} = event.data;
          const toUser = space.toPerson;
          const isSelf = activity.actor.id === currentUser.id;
          // Ignore activity from other conversations
          if (activity.target && activity.target.id === space.id) {
            switch (activity.verb) {
              case 'acknowledge':
                if (activity.object.objectType === 'activity' && isSelf) {
                  nextProps.handleEvent(eventNames.SPACES_READ, constructRoomsEventData(space, activity));
                }
                break;
              case 'share':
              case 'post':
                if (!isSelf) {
                  nextProps.handleEvent(eventNames.SPACES_UNREAD, constructRoomsEventData(space, activity));
                }
                // Emit message:created event
                nextProps.handleEvent(eventNames.MESSAGES_CREATED, constructMessagesEventData(activity, toUser));
                break;
              default: {
                break;
              }
            }
          }
        });
      }
    }
  })
);
