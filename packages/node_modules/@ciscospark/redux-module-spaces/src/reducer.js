import {
  fromJS,
  Map,
  OrderedMap,
  Record
} from 'immutable';

import {
  STORE_SPACES,
  REMOVE_SPACE,
  UPDATE_SPACE_READ,
  STORE_INITIAL_SPACE,
  UPDATE_SPACE_WITH_ACTIVITY,
  UPDATE_SPACE_STATUS,
  ACKNOWLEDGE_ACTIVITY,
  ADD_PARTICIPANT,
  REMOVE_PARTICIPANT,
  ADD_ACTIVITIES_TO_SPACE,
  ADD_PARTICIPANT_ACKNOWLEDGEMENT,
  ADD_SPACES_ERROR,
  ADD_SPACE_ERROR
} from './actions';

const Participant = Record({
  id: '',
  lastSeenActivityUuid: null,
  lastSeenActivityDate: null
});


export const Space = Record({
  latestActivity: null,
  avatar: '',
  displayName: '',
  id: null,
  url: '',
  locusUrl: '',
  activities: OrderedMap(),
  lastReadableActivityDate: '',
  lastSeenActivityDate: '',
  lastActivityTimestamp: '',
  conversation: null,
  conversationWebUrl: '',
  participants: Map(),
  lastAcknowledgedActivityId: '',
  type: '',
  published: '',
  tags: [],
  team: null,
  error: null,
  isDecrypting: false,
  isLocked: false,
  isOneOnOne: null,
  isHidden: false,
  isFetching: false,
  isLoadingHistory: false,
  isLoadingActivitiesSince: false,
  isListeningToMercury: false
});

export const initialState = fromJS({
  byId: {},
  errors: null
});


export default function reducer(state = initialState, action) {
  switch (action.type) {
    case STORE_INITIAL_SPACE: {
      const {id} = action.payload;
      return state.setIn(['byId', id], new Space({
        id,
        isFetching: true
      }));
    }

    case STORE_SPACES: {
      const spaces = {};
      action.payload.spaces.forEach((s) => {
        const space = new Space(s);
        space.activities.set(space.activities.sortBy((a) => a));
        spaces[s.id] = space;
      });
      return state.mergeDeepIn(['byId'], spaces);
    }

    case UPDATE_SPACE_STATUS: {
      const {id, status} = action.payload;
      return state.mergeIn(['byId', id], status);
    }

    case UPDATE_SPACE_WITH_ACTIVITY: {
      const {space} = action.payload;
      if (state.hasIn(['byId', space.id])) {
        return state.mergeDeepIn(['byId', space.id], space);
      }
      return state;
    }

    case ACKNOWLEDGE_ACTIVITY: {
      const {spaceId, activityId} = action.payload;
      return state.setIn(['byId', spaceId, 'lastAcknowledgedActivityId'], activityId);
    }

    case UPDATE_SPACE_READ: {
      const {lastSeenDate, id} = action.payload;
      return state.setIn(['byId', id, 'lastSeenActivityDate'], lastSeenDate);
    }

    case REMOVE_SPACE:
      return state.deleteIn(['byId', action.payload.id]);

    case ADD_PARTICIPANT: {
      const {spaceId, participantId} = action.payload;
      return state.setIn(['byId', spaceId, 'participants', participantId], new Participant({id: participantId}));
    }

    case REMOVE_PARTICIPANT: {
      const {spaceId, participantId} = action.payload;
      return state.deleteIn(['byId', spaceId, 'participants', participantId]);
    }

    case ADD_PARTICIPANT_ACKNOWLEDGEMENT: {
      const {
        spaceId,
        participantId,
        lastSeenActivityUuid,
        lastSeenActivityDate
      } = action.payload;
      return state.mergeDeepIn(['byId', spaceId, 'participants', participantId], {
        lastSeenActivityUuid,
        lastSeenActivityDate
      });
    }

    case ADD_ACTIVITIES_TO_SPACE: {
      const {activities, spaceId} = action.payload;
      const newActivities = state.getIn(['byId', spaceId, 'activities'])
        .merge(activities).sortBy((a) => a);
      return state.setIn(['byId', spaceId, 'activities'], newActivities);
    }

    case ADD_SPACES_ERROR: {
      return state.set('error', action.payload.error);
    }

    case ADD_SPACE_ERROR: {
      const {id, error} = action.payload;
      return state.mergeIn(['byId', id, error], error);
    }

    default:
      return state;
  }
}
