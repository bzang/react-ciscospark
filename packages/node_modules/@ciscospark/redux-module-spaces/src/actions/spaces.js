import {storeUsers} from '@ciscospark/redux-module-users';
import {storeActivities} from '@ciscospark/redux-module-activities';

import {constructSpace} from './helpers';

export const STORE_SPACES = 'spaces/STORE_SPACES';
export const REMOVE_SPACE = 'spaces/REMOVE_SPACE';
export const UPDATE_SPACE_READ = 'spaces/UPDATE_SPACE_READ';
export const UPDATE_SPACE_STATUS = 'spaces/UPDATE_SPACE_STATUS';
export const STORE_INITIAL_SPACE = 'spaces/STORE_INITIAL_SPACE';

/**
 * Updates the last seen date of a space
 * @param {String} id
 * @param {String} lastSeenDate
 * @returns {Object}
 */
export function updateSpaceRead(id, lastSeenDate) {
  return {
    type: UPDATE_SPACE_READ,
    payload: {
      lastSeenDate,
      id
    }
  };
}

/**
 * Updates the last seen date of a space
 * @param {String} id
 * @param {Object} status
 * @returns {Object}
 */
export function updateSpaceStatus(id, status) {
  return {
    type: UPDATE_SPACE_STATUS,
    payload: {
      status,
      id
    }
  };
}

export function removeSpace(id) {
  return {
    type: REMOVE_SPACE,
    payload: {
      id
    }
  };
}


function storeSpaces(spaces) {
  return {
    type: STORE_SPACES,
    payload: {
      spaces
    }
  };
}

function storeSpace(space) {
  return storeSpaces([space]);
}

function storeInitialSpace(id) {
  return {
    type: STORE_INITIAL_SPACE,
    payload: {
      id
    }
  };
}

function decryptSpace(space) {
  if (typeof space.decrypt === 'function') {
    return space.decrypt()
      .then((s) => Promise.resolve(s));
  }
  return Promise.resolve(new Error('Space cannot be decrypted'));
}


function processSpace(space, options) {
  return (dispatch) => {
    const activities = space.activities.items;
    const participants = space.participants.items;
    const activityActors = activities.map((a) => a.actor);
    dispatch(storeUsers([...participants, ...activityActors]));
    dispatch(storeActivities(activities));
    const constructedSpace = constructSpace(space, options);
    dispatch(storeSpace(constructedSpace));
    return Promise.resolve(space);
  };
}

/**
 * Fetches a list of spaces with options
 *
 * @export
 * @param {Object} sparkInstance
 * @param {Object} options
 * @returns {Function} thunk
 */
export function getSpaces(sparkInstance, options = {}) {
  const listOptions = Object.assign({
    ackFilter: 'noack',
    uuidEntryFormat: true,
    personRefresh: true,
    latestActivity: '',
    isActive: true,
    lastViewableActivityOnly: true,
    participantAckFilter: 'all',
    deferDecrypt: false,
    conversationLimit: 20,
    activitiesLimit: 20,
    // Only need 2 for One on One conversations
    participantsLimit: 2
  }, options);

  const {deferDecrypt} = options;
  return (dispatch) => sparkInstance.internal.conversation
    .list(listOptions)
    .then((items) => {
      const spaces = items.map((space) => {
        // Immediately store everything
        const s = dispatch(processSpace(space, {isDecrypting: deferDecrypt}));

        // Start decryption if necessary
        if (deferDecrypt && space.decrypt) {
          decryptSpace(space)
            .then((decryptedSpace) => {
              if (decryptedSpace) {
                return Promise.resolve(
                  dispatch(processSpace(decryptedSpace, {isDecrypting: false}))
                );
              }
              return Promise.resolve(new Error('Space was not decrypted correctly'));
            });
        }
        return s;
      });
      return Promise.resolve(spaces);
    });
}

/**
 * Fetches a list of recent spaces for the authenticated sparkInstance
 *
 * @export
 * @param {Object} sparkInstance
 * @param {Object} options to pass to SDK
 * @returns {Function} thunk
 */
export function fetchSpaces(sparkInstance, options = {}) {
  return (dispatch) =>
    dispatch(getSpaces(sparkInstance, {
      conversationsLimit: options.limit || 15,
      deferDecrypt: options.deferDecrypt || false
    }));
}


/**
 * Fetches single space from server
 *
 * @export
 * @param {Object} sparkInstance
 * @param {String} spaceId
 * @returns {function} thunk
 */
export function fetchSpace(sparkInstance, spaceId) {
  return (dispatch) => {
    dispatch(storeInitialSpace(spaceId));
    return sparkInstance.internal.conversation.get({
      id: spaceId
    }, {
      activitiesLimit: 25,
      participantAckFilter: 'all',
      includeParticipants: true
    })
      .then((space) => Promise.resolve(dispatch(processSpace(space))));
  };
}


/**
 * Creates/Opens a space with a user
 *
 * @param {object} sparkInstance
 * @param {Array} participants List of userIds or emails
 * @returns {function}
 */
export function createSpace(sparkInstance, participants = []) {
  return (dispatch) =>
    // TODO: Block multiple creations somehow
    sparkInstance.internal.conversation.create({
      participants
    }, {
      latestActivity: true,
      activitiesLimit: 40,
      participantAckFilter: 'all'
    })
      .then((space) => Promise.resolve(dispatch(processSpace(space))));
}
