import {createSelector} from 'reselect';
import moment from 'moment';

import {
  ITEM_TYPE_ACTIVITY,
  ITEM_TYPE_DAY_SEPARATOR,
  ITEM_TYPE_NEW_MESSAGE_SEPARATOR
} from '@ciscospark/react-component-activity-list';


import {
  isActivityVisible,
  formatActivity
} from './helpers';

const getActivities = (state) => state.activities;
const getSpace = (state, props) => props.spaces.getIn(['byId', props.spaceId]);
const getAvatars = (state) => state.avatar.get('items');
const getCurrentUser = (state) => state.users.getIn(['byId', state.users.get('currentUserId')]);
const getFlags = (state) => state.flags.get('flags');
const getInflightMessages = (state) => state.messaging.get('inFlightMessages');
const getMessageFailures = (state) => state.messaging.get('messageFailures');

const getActivityFormatter = (state, props) => props.activityFormatter;
const getOnEvent = (state, props) => props.onEvent;

const getLastAcknowledgedActivityId = (state, props) =>
  props.spaces.getIn(['byId', props.spaceId]).lastAcknowledgedActivityId;

const getSpaceActivities = createSelector(
  [getActivities, getSpace],
  (activities, space) => {
    if (space && space.activities) {
      return Object.keys(space.activities).map((s) => activities.getIn(['byId', s]));
    }
    return [];
  }
);

/**
 * This loops through our conversation activities and computes an array
 * of 'visible activities' to be used with the ActivityList component
 */
export default createSelector(
  [
    getSpaceActivities,
    getAvatars,
    getCurrentUser,
    getInflightMessages,
    getMessageFailures,
    getFlags,
    getLastAcknowledgedActivityId,
    getActivityFormatter,
    getOnEvent
  ],
  (
    activities,
    avatars,
    currentUser,
    inFlightMessages,
    messageFailures,
    flags,
    lastAcknowledgedActivityId,
    activityFormatter,
    onEvent
  ) => {
    const visibleActivityList = [];
    const now = moment();
    let lastActorId, lastDay, lastMinute, lastVerb;
    let shouldDisplayNewMessageMarker = false;

    activities.forEach((activity) => {
      if (isActivityVisible(activity)) {
        // Insert day separator if this activity and last one happen on a different day
        const activityDay = moment(activity.published, moment.ISO_8601).endOf('day');
        const activityMinute = moment(activity.published, moment.ISO_8601).endOf('minute');

        const sameDay = activityDay.diff(lastDay, 'days') === 0;
        const sameMinute = activityMinute.diff(lastMinute, 'minutes') === 0;

        if (lastDay && !sameDay) {
          visibleActivityList.push({
            type: ITEM_TYPE_DAY_SEPARATOR,
            fromDate: lastDay,
            key: `day-separtor-${activity.id}`,
            now,
            toDate: activityDay
          });
        }
        lastDay = activityDay;
        lastMinute = activityMinute;

        // New message marker
        if (shouldDisplayNewMessageMarker) {
          visibleActivityList.push({
            type: ITEM_TYPE_NEW_MESSAGE_SEPARATOR,
            key: `new-messages-${activity.id}`
          });
          shouldDisplayNewMessageMarker = false;
        }

        // Actual visible activity item
        // additional items don't repeat user avatar and name
        const isAdditional = sameDay && sameMinute &&
          lastActorId === activity.actor.id &&
          lastVerb === activity.verb;
        lastActorId = activity.actor.id;
        lastVerb = activity.verb;

        const isFlagged = !!flags.count() && flags.has(activity.url);
        const isFlagPending = isFlagged && flags.getIn([activity.url, 'isInFlight']);

        let formattedActivity = activity;
        if (activity.verb === 'post') {
          formattedActivity = Object.assign({}, activity, {
            object: formatActivity({
              activity: activity.object,
              formatter: activityFormatter,
              onEvent
            })
          });
        }

        // Name of the user
        let name = activity.actor.displayName;
        if (activity.verb === 'add' || activity.verb === 'leave') {
          name = activity.object.displayName;
        }

        const visibleActivity = {
          currentUser,
          type: ITEM_TYPE_ACTIVITY,
          activity: formattedActivity,
          avatarUrl: avatars.get(activity.actor.id),
          isSelf: currentUser.id === activity.actor.id,
          isAdditional,
          isFlagged,
          isFlagPending,
          name
        };

        visibleActivityList.push(visibleActivity);

        // Check if this is the last read activity
        const isLastAcked = lastAcknowledgedActivityId && lastAcknowledgedActivityId === activity.id;
        const isNotSelf = currentUser.id !== activity.actor.id;
        if (isLastAcked && isNotSelf) {
          shouldDisplayNewMessageMarker = true;
        }
      }
    });

    // Create a "fake" activity to display in flight activities
    inFlightMessages.forEach((inFlightActivity) => {
      visibleActivityList.push({
        currentUser,
        type: ITEM_TYPE_ACTIVITY,
        activity: inFlightActivity,
        avatarUrl: avatars.get(currentUser.id),
        isAdditional: false,
        isFlagged: false,
        isFlagPending: false,
        isSelf: true,
        isPending: true
      });
    });

    // Create a "fake" activity to display failed activities
    messageFailures.forEach((activityFailure) => {
      visibleActivityList.push({
        currentUser,
        type: ITEM_TYPE_ACTIVITY,
        activity: activityFailure,
        avatarUrl: avatars.get(currentUser.id),
        isAdditional: false,
        hasError: true,
        isFlagged: false,
        isFlagPending: false,
        isSelf: true,
        isPending: true
      });
    });

    return visibleActivityList;
  }
);
