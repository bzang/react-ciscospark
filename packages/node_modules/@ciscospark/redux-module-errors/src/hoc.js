import React, {Component} from 'react';
import PropTypes from 'prop-types';
import classNames from 'classnames';

import {connect} from 'react-redux';
import {bindActionCreators} from 'redux';

function getDisplayName(C) {
  return C.displayName || C.name || `C`;
}

export default function errorHOC(WrappedComponent) {
  class ErrorsHOC extends Component {
    componentDidMount() {
      this.checkForErrors(nextProps);
    }

    componentWillReceiveProps(nextProps) {
      this.checkForErrors(nextProps);
    }

    shouldComponentUpdate(nextProps) {
      return nextProps !== this.props;
    }

    checkForErrors(props) {
      const {
        conversation,
        errors,
        spaceId,
        sparkInstance,
        sparkState,
        spark,
        toPersonEmail,
        toPersonId,
        mercury,
        metrics,
        users,
        spaceDetails,
        widgetSpace,
        widgetStatus
      } = props;
      const registerErrorId = `spark.register`;
      if (
        sparkState.get(`registerError`)
        && (!errors.get(`hasError`) || !errors.get(`errors`).has(registerErrorId))
      ) {
        const error = spark.get(`error`);
        let displaySubtitle = formatMessage(messages.unknownError);
        if (error.statusCode === 401) {
          displaySubtitle = formatMessage(messages.errorBadToken);
        }
        props.addError({
          id: registerErrorId,
          displayTitle: formatMessage(messages.unableToLoad),
          displaySubtitle,
          temporary: false,
          code: error.statusCode
        });
      }
    }

    checkForMercuryErrors(props) {
      const {
        errors,
        intl,
        mercury
      } = props;
      // Add Mercury disconnect error
      const mercuryError = `mercury.disconnect`;
      const isMercuryConnected = mercury.getIn([`status`, `connected`]);
      const isMercuryDisconnected = !isMercuryConnected && mercury.getIn([`status`, `hasConnected`]);
      const hasError = errors.get(`hasError`);
      const hasMercuryError = errors.get(`errors`).has(mercuryError);
      const hasNoMercuryError = !hasError || !hasMercuryError;
      if (isMercuryDisconnected && hasNoMercuryError) {
        // Create UI Error
        const {formatMessage} = intl;
        props.addError({
          id: mercuryError,
          displayTitle: formatMessage(messages.errorConnection),
          displaySubtitle: formatMessage(messages.reconnecting),
          temporary: true
        });
      }
      if (isMercuryConnected && hasMercuryError) {
        props.removeError(mercuryError);
      }
    }

    render() {
      const props = this.props;
      const {
        errors
      } = props;
      let displaySubtitle, displayTitle, errorAction, errorActionTitle, temporary, widgetError;
      if (errors.get(`hasError`)) {
        widgetError = errors.get(`errors`).first();
        errorAction = widgetError.onAction;
        errorActionTitle = widgetError.actionTitle;
        displayTitle = widgetError.displayTitle;
        displaySubtitle = widgetError.displaySubtitle;
        temporary = widgetError.temporary;
      }

      return (
        <div>
          {
            errors.get(`hasError`) &&
            <div className={classNames(`ciscospark-error-wrapper`, styles.errorWrapper)}>
              <ErrorDisplay
                actionTitle={errorActionTitle}
                onAction={errorAction}
                secondaryTitle={displaySubtitle}
                title={displayTitle}
                transparent={temporary}
              />
            </div>
          }
          <WrappedComponent {...this.props} />
        </div>
      );
    }
  }

  ErrorsHOC.displayName = `ErrorsHOC(${getDisplayName(WrappedComponent)})`;
  ErrorsHOC.WrappedComponent = WrappedComponent;

  ErrorsHOC.propTypes = {
  };

  return connect(
    (state) => ({
      errors
    }),
    (dispatch) => bindActionCreators({

    }, dispatch)
  )(ErrorsHOC);
}
