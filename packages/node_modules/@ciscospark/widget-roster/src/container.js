import React, {Component} from 'react';
import PropTypes from 'prop-types';
import {connect} from 'react-redux';
import {compose} from 'recompose';
import {bindActionCreators} from 'redux';
import classNames from 'classnames';
import {autobind} from 'core-decorators';
import {debounce} from 'lodash';
import isEmail from 'validator/lib/isEmail';

import {fetchAvatarsForUsers} from '@ciscospark/redux-module-avatar';
import {addParticipantToSpace, removeParticipantFromSpace} from '@ciscospark/redux-module-spaces';
import {searchForUser} from '@ciscospark/redux-module-search';
import LoadingScreen from '@ciscospark/react-component-loading-screen';
import wrapConversationMercury from '@ciscospark/react-hoc-conversation-mercury';
import Icon, {ICON_TYPE_ADD} from '@ciscospark/react-component-icon';
import PeopleList from '@ciscospark/react-component-people-list';
import ActivityMenuHeader from '@ciscospark/react-component-activity-menu-header';

import {getRosterWidgetProps} from './selector';
import {setParticipantEditing, setSearchTerm, setWidgetViewAdd, setWidgetViewMain, VIEW_ADD} from './actions';
import messages from './messages';
import styles from './styles.css';
import AddParticipant from './components/add-participant';
import ExternalParticipantMessage from './components/external-participant';
import RosterParticipantDetails from './components/participant-details';

/**
 * RosterWidget Container
 * @extends Component
 */
export class RosterWidget extends Component {
  constructor(props) {
    super(props);
    this.doSearch = debounce(this.doSearch, 1000);
    const {formatMessage} = props.intl;
    this.formattedMessages = {
      addPeople: formatMessage(messages.addPeople),
      addPlaceholder: formatMessage(messages.addPlaceholder),
      cancelDetails: formatMessage(messages.cancelDetails),
      externalParticipants: formatMessage(messages.externalParticipants),
      moderators: formatMessage(messages.moderators),
      noResults: formatMessage(messages.noResults),
      participants: formatMessage(messages.participants),
      removeParticipant: formatMessage(messages.removeParticipant)
    };
  }


  shouldComponentUpdate(nextProps) {
    return nextProps.avatar.get('items') !== this.props.avatar.get('items')
      || nextProps.conversation.get('participants') !== this.props.conversation.get('participants')
      || nextProps.canEditRoster !== this.props.canEditRoster
      || nextProps.currentView !== this.props.widgetRoster.currentView
      || nextProps.searchResults !== this.props.searchResults;
  }

  componentWillUpdate(nextProps) {
    this.props.fetchAvatarsForUsers(
      nextProps.conversation.get('participants').map((user) => user.id),
      this.props.sparkInstance
    );
    // Fetch avatars for searched users
    if (nextProps.searchResults
      && nextProps.searchResults !== this.props.searchResults
      && nextProps.searchResults.results
    ) {
      this.props.fetchAvatarsForUsers(nextProps.searchResults.results.map((user) => user.id), this.props.sparkInstance);
    }
  }

  @autobind
  handleMenuClick() {
    this.props.onClickMenu();
  }

  @autobind
  handleCloseClick() {
    this.props.onClickClose();
  }

  @autobind
  handleAddPeople() {
    this.props.setWidgetViewAdd();
  }

  @autobind
  handleAddPeopleDismiss() {
    this.props.setWidgetViewMain();
  }

  @autobind
  handleAddPersonClick(person) {
    const {
      space,
      sparkInstance
    } = this.props;
    this.props.setWidgetViewMain();
    this.props.addParticipantToSpace(sparkInstance, {conversation: space.conversation, person});
  }

  @autobind
  handleSearchInput(searchTerm) {
    this.props.setSearchTerm(searchTerm);
    // Consumer org can only search via email
    if (this.props.isConsumerOrg && isEmail(searchTerm) || !this.props.isConsumerOrg && searchTerm.length >= 3) {
      this.doSearch(searchTerm);
    }
  }

  @autobind
  handleRosterEdit(participant) {
    this.props.setParticipantEditing(participant);
  }

  @autobind
  handleRosterEditDismiss() {
    this.props.setParticipantEditing(false);
  }

  @autobind
  handleRosterRemove(participant) {
    const {
      space,
      sparkInstance
    } = this.props;
    this.props.removeParticipantFromSpace(sparkInstance, {conversation: space.conversation, participant});
    this.props.setParticipantEditing(false);
  }

  @autobind
  doSearch(searchTerm) {
    // Only actually search if we don't have search results for the term
    if (searchTerm === this.props.searchTerm && !this.props.searchResults) {
      this.props.searchForUser(searchTerm, this.props.sparkInstance);
    }
  }

  /**
   * Renders the main area of the widget
   *
   * @returns {object}
   */
  render() {
    let mainArea;
    const {
      canEditRoster,
      editingParticipant,
      participants
    } = this.props;

    if (!this.props.conversation.has('participants')) {
      mainArea = <LoadingScreen />;
    }
    else {
      const {
        currentView,
        searchResults,
        searchTerm
      } = this.props;
      let content;
      if (currentView === VIEW_ADD) {
        content = (
          <div>
            <AddParticipant
              noResultsMessage={this.formattedMessages.noResults}
              onAddPerson={this.handleAddPersonClick}
              onChange={this.handleSearchInput}
              onDismiss={this.handleAddPeopleDismiss}
              placeholder={this.formattedMessages.addPlaceholder}
              searchResults={searchResults}
              searchTerm={searchTerm}
            />
          </div>
        );
      }
      else {
        let addPeopleButton;
        if (canEditRoster) {
          addPeopleButton = (
            // eslint-disable-reason false positive until a11y plugin upgraded to ^5.0
            // eslint-disable-next-line jsx-a11y/no-static-element-interactions
            <div
              className={classNames('ciscospark-roster-add-people', styles.addPeople)}
              onClick={this.handleAddPeople}
              onKeyPress={this.handleAddPeople}
              role="button"
              tabIndex="0"
            >
              <div className={classNames(styles.addPeopleIcon)}>
                <Icon type={ICON_TYPE_ADD} />
              </div>
              <div>
                {this.formattedMessages.addPeople}
              </div>
            </div>
          );
        }
        content = (
          <div>
            {addPeopleButton}
            <PeopleList
              items={participants.people}
              onItemClick={this.handleRosterEdit}
            />
          </div>
        );
      }

      mainArea = (
        <div>
          {
            participants.hasExternalParticipants
            && <ExternalParticipantMessage message={this.formattedMessages.externalParticipants} />
          }
          {content}
        </div>
      );
    }
    return (
      <div className={classNames('ciscospark-roster', styles.roster)}>
        <ActivityMenuHeader
          onClose={this.handleCloseClick}
          onMenuClick={this.handleMenuClick}
          title={`People (${participants.count ? participants.count : null})`}
        />
        <div className={classNames('ciscospark-roster-scrolling-list', styles.scrolling)} >
          {mainArea}
        </div>
        {
          editingParticipant &&
          <div className={classNames('ciscospark-roster-action-sheet', styles.actionSheet)} >
            <RosterParticipantDetails
              canEdit={canEditRoster}
              onCancel={this.handleRosterEditDismiss}
              onRemove={this.handleRosterRemove}
              participant={editingParticipant}
              titleCancel={this.formattedMessages.cancelDetails}
              titleRemove={this.formattedMessages.removeParticipant}
            />
          </div>
        }
      </div>
    );
  }
}

const injectedPropTypes = {
  canEditRoster: PropTypes.bool.isRequired,
  conversation: PropTypes.object.isRequired,
  currentView: PropTypes.string.isRequired,
  editingParticipant: PropTypes.oneOfType([
    PropTypes.object,
    PropTypes.bool
  ]),
  isConsumerOrg: PropTypes.bool.isRequired,
  participants: PropTypes.shape({
    hasExternalParticipants: PropTypes.bool.isRequired,
    people: PropTypes.array,
    count: PropTypes.number.isRequired
  }),
  searchResults: PropTypes.object,
  searchTerm: PropTypes.string,
  sparkInstance: PropTypes.object,
  user: PropTypes.object.isRequired,
  widgetRoster: PropTypes.object.isRequired,
  addParticipantToSpace: PropTypes.func.isRequired,
  fetchAvatarsForUsers: PropTypes.func.isRequired,
  removeParticipantFromSpace: PropTypes.func.isRequired,
  searchForUser: PropTypes.func.isRequired,
  setParticipantEditing: PropTypes.func.isRequired,
  setSearchTerm: PropTypes.func.isRequired,
  setWidgetViewAdd: PropTypes.func.isRequired,
  setWidgetViewMain: PropTypes.func.isRequired
};

export const ownPropTypes = {
  onClickClose: PropTypes.func,
  onClickMenu: PropTypes.func,
  onEvent: PropTypes.func,
  spaceId: PropTypes.string,
  eventNames: PropTypes.object
};

RosterWidget.propTypes = {
  ...ownPropTypes,
  ...injectedPropTypes
};

export default compose(
  wrapConversationMercury,
  connect(
    getRosterWidgetProps,
    (dispatch) => bindActionCreators({
      addParticipantToSpace,
      fetchAvatarsForUsers,
      removeParticipantFromSpace,
      searchForUser,
      setParticipantEditing,
      setSearchTerm,
      setWidgetViewAdd,
      setWidgetViewMain
    }, dispatch)
  )
)(RosterWidget);
