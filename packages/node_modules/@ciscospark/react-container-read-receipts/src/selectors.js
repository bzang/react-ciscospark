import {createSelector} from 'reselect';
import {orderBy} from 'lodash';

const getUsers = (state) => state.users.get('byId');
const getCurrentUser = (state) => state.users.getIn(['byId', state.users.get('currentUserId')]);
const getTypingIndicators = (state) => state.indicators.get('typing');
const getSpark = (state, ownProps) => ownProps.sparkInstance || state.spark.get('spark');
const READ_RECEIPTS_SHOWN_LIMIT = 10;

const getSpace = (state, ownProps) => state.spaces.getIn(['byId', ownProps.spaceId]);

const getParticipants = createSelector(
  [getSpace, getUsers],
  (space, users) => space.participants.map((id) => users.get(id))
);

const getLastActivity = createSelector(
  [getSpace], (space) => space.activities.last()
);

const getReadReceipts = createSelector(
  [getCurrentUser, getLastActivity, getParticipants, getTypingIndicators],
  (currentUser, lastActivity, participants, typing) => {
    const readParticipants = participants
      .filter((participant) =>
        participant.get('id') !== currentUser.id &&
        participant.getIn(['roomProperties', 'lastSeenActivityUUID']) === lastActivity.id)
      .toJS();

    const mappedParticipants = readParticipants
      .map((participant) => {
        const participantId = participant.id;
        // Typing events don't give us user IDs, only emails.
        const isTyping = typing.has(participant.emailAddress);
        return {
          displayName: participant.displayName,
          isTyping,
          userId: participantId
        };
      });
    const sortedParticipants = orderBy(mappedParticipants, 'isTyping', 'desc');
    const visibleUsers = sortedParticipants.slice(0, READ_RECEIPTS_SHOWN_LIMIT);
    const hiddenUsers = sortedParticipants.slice(READ_RECEIPTS_SHOWN_LIMIT);

    return {
      hiddenUsers,
      visibleUsers
    };
  }
);

const getReadReceiptsProps = createSelector(
  [getReadReceipts, getSpark],
  (readReceipts, sparkInstance) => ({
    readReceipts,
    sparkInstance
  })
);

export default getReadReceiptsProps;
